/**
 * Even Fibonacci numbers
 * 
 * Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
 * By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
 */

/**
 * Let F(n) = nth Fibonacci number with F(1) = F(2) = 1, then it can be shown that F(n) = (phi^n - (-phi)^-n)/sqrt(5), phi = (1+sqrt(5))/2
 * It can also be shown that F(3n) are the only even Fibonacci numbers (odd+odd=even, even+odd=odd, F(1) and F(2) are both odd => F(3) even => F(4) odd => ...)
 * Hence we are looking for the sum of F(3i), i=1..N, N st F(3N)<4,000,000 and F(3N+3)>4,000,000
 * 
 * To calculate N we need to find the inverse of F(3N) = (phi^(3N) - (-phi)^(-3N))/sqrt(5) = 4,000,000
 * Since phi^(-3N) = 1/(phi^(3N)), if F(3N) ~= 4,000,000 then phi^(-3N) ~= 0 => phi^(3N) ~= F(3N)*sqrt(5)
 * So we know that N <= (log(4,000,000*sqrt(5))/log(phi))/3
 * 
 * To sum the Fibonacci numbers we observe that (sum F(3i), i=1..N) = (sum phi^(3i), i=1..N)/sqrt(5) - (sum (-phi)^(-3i), i=1..N)/sqrt(5)
 *   = ((phi^3-phi^(3N+3))/(1-phi^3) - ((-phi)^-3-(-phi)^(-3N-3))/(1-(-phi)^-3))/sqrt(5)
 *   = (phi^3 * (1-phi^(3N))/(1-phi^3) + phi^-3 * (1-(-phi)^(-3N))/(1+phi^-3))/sqrt(5)
 *   = ((1-phi^(3N))/(phi^(-3)-1) + (1-(-phi)^(-3N))/(1+phi^3))/sqrt(5)
 *   = ((phi^(3N)-1)/(psi^(3)+1) + (1-psi^(3N))/(1+phi^3))/sqrt(5)
 */



// Common includes
#include "common.h"



// Begin the solution
SOLUTION_BEGIN(2, uint64_t)
{
	// The largest value
	const uint64_t max = 4000000;
	
	// Calculate some constants
	const double sqrt5 = sqrt(5);
	const double phi = (1.0 + sqrt5) / 2.0;
	const double psi = (1.0 - sqrt5) / 2.0;	// = 1/phi
	
	// Calculate N as above
	uint64_t N = log(max * sqrt5) / (log(phi) * 3.0);
	
	// Get the ith Fibonacci number
	auto Fibonacci = [&](uint64_t i)
	{
		// Calculate the two parts
		const double phipow = std::pow(phi, i);
		const double psipow = std::pow(psi, i);
		
		// Deal with (-1)^i
		if ((i % 2) == 0)
			return (phipow - psipow)/sqrt5;
		else
			return (phipow + psipow)/sqrt5;
	};
	
	// Do some checks to make sure N is the largest
	while (Fibonacci(3*N) < max) N++;
	while (Fibonacci(3*N) > max) N--;
	
	// So we don't have to keep doing that
	N *= 3;
	
	// Calculate the parts of the sum
	double resultd = 0;
	const double sign = ((N % 2) == 0) ? 1.0 : -1.0;
	resultd += (std::pow(phi, N) - 1) / (psi*psi*psi + 1);
	resultd += (1 - std::pow(psi, N) * sign) / (phi*phi*phi + 1);
	resultd /= sqrt5;
	
	// This needs to be called since a static cast doesn't do the job (despite the value showing as correct before the cast)
	result = std::lround(resultd);
	
}
SOLUTION_END()
